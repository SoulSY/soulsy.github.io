<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SamTech</title>
    <link>https://soulsy.github.io/ko/dev/</link>
    <description>Recent content on SamTech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Tue, 20 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://soulsy.github.io/ko/dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>디자인 패턴 05. Prototype Pattern</title>
      <link>https://soulsy.github.io/ko/dev/design_pattern/prototype_pattern/</link>
      <pubDate>Tue, 20 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://soulsy.github.io/ko/dev/design_pattern/prototype_pattern/</guid>
      <description>Prototype 패턴 개요 Prototype 패턴은 객체 생성 비용을 줄이고, 새로운 객체를 생성하기 위해 기존 객체를 복제하는 디자인 패턴입니다. Prototype 패턴은 다음과 요소를 가지고 있습니다:
Prototype 인터페이스 또는 추상 클래스: 복제 기능을 선언하는 메서드를 정의합니다. ConcretePrototype 클래스: Prototype 인터페이스를 구체적으로 구현하고, 객체의 복제를 수행하는 메서드를 제공합니다. Client: 복제를 요청하고, 새로운 객체를 생성하는 역할을 합니다. // Prototype 인터페이스 public interface Prototype { Prototype clone(); } // ConcretePrototype 클래스 public class ConcretePrototype implements Prototype { private String property; public ConcretePrototype(String property) { this.</description>
    </item>
    
    <item>
      <title>디자인 패턴 04. Builder Pattern</title>
      <link>https://soulsy.github.io/ko/dev/design_pattern/builder_pattern/</link>
      <pubDate>Mon, 19 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://soulsy.github.io/ko/dev/design_pattern/builder_pattern/</guid>
      <description>Builder 패턴의 개요 Builder 패턴은 객체 생성을 유연하고 직관적으로 만들기 위한 디자인 패턴입니다. 이 패턴은 복잡한 객체의 생성 과정을 추상화하고, 사용자가 단계별로 객체를 구성할 수 있게 합니다.
Builder 패턴은 다음과 같은 요소로 구성됩니다:
Director: 객체 생성을 담당하며, Builder 인터페이스를 사용하여 객체를 구성합니다. Builder: 객체 생성을 위한 인터페이스를 정의하고, 객체의 각 부분을 구성하는 메서드를 제공합니다. ConcreteBuilder: Builder 인터페이스를 구현하여 객체를 구성하는 역할을 합니다. Product: 생성할 객체의 표현입니다. // Product 클래스 public class Product { private String partA; private String partB; private String partC; public void setPartA(String partA) { this.</description>
    </item>
    
    <item>
      <title>디자인 패턴 03. Singleton Pattern</title>
      <link>https://soulsy.github.io/ko/dev/design_pattern/singleton_pattern/</link>
      <pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://soulsy.github.io/ko/dev/design_pattern/singleton_pattern/</guid>
      <description>Singleton 패턴은 클래스의 인스턴스가 단일하게 유지되도록 보장하는 디자인 패턴입니다. 이 패턴은 어떤 클래스의 인스턴스가 하나만 존재하고, 이를 전역적으로 접근할 수 있는 방법을 제공합니다.
Singleton 패턴의 개요 Singleton 패턴은 다음과 같은 특징을 가집니다:
클래스의 인스턴스가 오직 하나만 존재합니다. 전역적으로 접근 가능한 접근점을 제공하여 어디서든 동일한 인스턴스에 접근할 수 있습니다. Singleton 패턴은 다양한 상황에서 유용하게 사용될 수 있으며, 자주 사용되는 패턴 중 하나입니다.
Singleton 패턴의 장점 Singleton 패턴은 다음과 같은 장점을 가집니다:</description>
    </item>
    
    <item>
      <title>디자인 패턴 02. Abstract Factory Pattern</title>
      <link>https://soulsy.github.io/ko/dev/design_pattern/abstract_factory_pattern/</link>
      <pubDate>Fri, 16 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://soulsy.github.io/ko/dev/design_pattern/abstract_factory_pattern/</guid>
      <description>Abstract Factory 패턴은 관련된 객체들을 생성하는 인터페이스를 제공하여 객체 생성에 대한 책임을 분리하는 디자인 패턴입니다. 이 패턴은 서로 연관된 다수의 객체를 생성해야 할 때 유용하며, 구체적인 클래스에 의존하지 않고 객체를 생성할 수 있도록 합니다.
Abstract Factory 패턴의 개요 Abstract Factory 패턴은 클라이언트가 객체를 생성하는 대신, 추상 팩토리 인터페이스를 통해 관련 객체들을 생성합니다. 추상 팩토리는 관련된 객체들의 집합에 대한 인터페이스를 제공하며, 구체적인 팩토리 클래스는 이 인터페이스를 구현하여 실제 객체를 생성합니다. 이를 통해 클라이언트는 구체적인 클래스에 직접 의존하지 않고도 객체를 생성할 수 있습니다.</description>
    </item>
    
    <item>
      <title>디자인 패턴 01. Factory Pattern</title>
      <link>https://soulsy.github.io/ko/dev/design_pattern/factory_pattern/</link>
      <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://soulsy.github.io/ko/dev/design_pattern/factory_pattern/</guid>
      <description>Factory 패턴은 객체 생성을 캡슐화하여 유연성과 확장성을 제공하는 디자인 패턴입니다. 이 패턴은 클라이언트에게 직접 객체 생성을 맡기지 않고, 팩토리 메서드를 통해 객체를 생성하고 반환하는 방식을 사용합니다.
Factory 패턴의 개요 Factory 패턴은 클라이언트가 객체를 생성하는 대신, 팩토리 메서드를 호출하여 객체를 생성하고 반환합니다. 이를 통해 클라이언트는 객체 생성과 관련된 복잡한 로직을 알 필요 없이, 팩토리 메서드를 통해 쉽게 객체를 생성할 수 있습니다.
// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.</description>
    </item>
    
  </channel>
</rss>